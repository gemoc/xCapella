import org.eclipse.gemoc.moccml_mapping.EclQVToHelper;
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
	modeltype inMM1 uses 'http://www.polarsys.org/capella/core/modeller/1.3.0';
	modeltype inMM2 uses 'http://www.polarsys.org/capella/core/fa/1.3.0';
	modeltype inMM3 uses 'http://www.polarsys.org/capella/core/interaction/1.3.0';
	modeltype inMM4 uses 'http://www.polarsys.org/capella/core/information/1.3.0';
	modeltype inMM5 uses 'http://www.polarsys.org/capella/core/ctx/1.3.0';
	modeltype inMM6 uses 'http://www.polarsys.org/capella/core/common/1.3.0';
	modeltype inMM7 uses 'http://www.polarsys.org/capella/core/ctx/1.3.0';
	modeltype inMM8 uses 'http://www.polarsys.org/capella/core/information/1.3.0';
	modeltype inMM9 uses 'http://www.polarsys.org/capella/core/ctx/1.3.0';
	modeltype inMM10 uses 'http://www.polarsys.org/capella/core/fa/1.3.0';
	modeltype inMM11 uses 'http://www.polarsys.org/capella/core/interaction/1.3.0';

modeltype QVT 		uses 'http://www.eclipse.org/QVT/1.0.0/Operational';
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';
modeltype FeedBack 	uses 'http://timesquare.inria.fr/feedback';
modeltype Priority  uses 'http://fr.inria.aoste.timesquare.ccslkernel.solver.priorities';


transformation docapellamodeller_To_CCSL(in inM : inMM1, out ccsl : TimeModel, out feedback : FeedBack, out priority: Priority);

property thePrioritySpec		:Priority::PrioritySpecification = null;
property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};
property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;
property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;
property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};
property allVarDefs : Sequence(String) = Sequence{}; 

query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map capellamodeller2CCSL();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map capellamodeller2FeedBack();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map capellamodeller2Priority();
}

			
	mapping inMM1::Project::capellamodeller2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib';
			alias := 'lib4RT';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml';
			alias := 'temporalConstraints';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib';
			alias := 'SMCubeMoC';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml';
			alias := 'SMCubeMoCC';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		////[ AbstractEnd ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), AbstractEnd.oclAsType(EClass)).oclAsType(AbstractEnd)->map occurs2Clock();
		


		

		////[ ExchangeItem ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ExchangeItem.oclAsType(EClass)).oclAsType(ExchangeItem)->map occurs2Clock();
		


		

		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map enacts2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map unEnacts2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map starts2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map stops2Clock();
		


		

		////[ System ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map start2Clock();
		


		

		////[ Mode ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map entering2Clock();
		////[ Mode ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map leaving2Clock();
		


		

		////[ StateMachine ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map start2Clock();
		


		

		////[ StateTransition ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateTransition.oclAsType(EClass)).oclAsType(StateTransition)->map fire2Clock();
		


		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateTransition.oclAsType(EClass)).oclAsType(StateTransition)->map TAGshare42TAGshare();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateTransition.oclAsType(EClass)).oclAsType(StateTransition)->map TAGsNotSare42TAGsNotSare();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map enterOnceBeforeToLeave32enterOnceBeforeToLeave();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map firingATransitionMeansLeavingState32firingATransitionMeansLeavingState();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map stateEntering132stateEntering1();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map oneTransitionAtATime32oneTransitionAtATime();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map firstIsInitialState32firstIsInitialState();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map firstOnlyOnce22firstOnlyOnce();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map startTimedSystemBeforeAllStartComponent32startTimedSystemBeforeAllStartComponent();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map allStartsTogether32allStartsTogether();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map firstOnlyOnce22firstOnlyOnce();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ExchangeItem.oclAsType(EClass)).oclAsType(ExchangeItem)->map occursWhenFireIfInEffects42occursWhenFireIfInEffects();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ExchangeItem.oclAsType(EClass)).oclAsType(ExchangeItem)->map occursWhenAnyMEssageSent42occursWhenAnyMEssageSent();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ExchangeItem.oclAsType(EClass)).oclAsType(ExchangeItem)->map ifExchangeItemItOccurs32ifExchangeItemItOccurs();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map taskTaskInv32taskTaskInv();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map EnactedByAssociatedModeEntering42EnactedByAssociatedModeEntering();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map UnEnactedByAssociatedModeLeaving42UnEnactedByAssociatedModeLeaving();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FunctionalExchange.oclAsType(EClass)).oclAsType(FunctionalExchange)->map ConditionalAlternatesRelationFromFunctionalExchanges42ConditionalAlternatesRelationFromFunctionalExchanges();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FunctionalExchange.oclAsType(EClass)).oclAsType(FunctionalExchange)->map AlternatesRelationFromFunctionalExchanges32AlternatesRelationFromFunctionalExchanges();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FunctionalExchange.oclAsType(EClass)).oclAsType(FunctionalExchange)->map eventExchangeItemCanOccurOnlyInDedicatedContext32eventExchangeItemCanOccurOnlyInDedicatedContext();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FunctionalExchange.oclAsType(EClass)).oclAsType(FunctionalExchange)->map eventExchangeItemCanOccurOnlyInDedicatedContext232eventExchangeItemCanOccurOnlyInDedicatedContext2();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FunctionOutputPort.oclAsType(EClass)).oclAsType(FunctionOutputPort)->map outputPortsWithEventCanOccurDuringFunctionExecution52outputPortsWithEventCanOccurDuringFunctionExecution();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FunctionalChain.oclAsType(EClass)).oclAsType(FunctionalChain)->map globalAlternatesOnFC32globalAlternatesOnFC();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FunctionalChain.oclAsType(EClass)).oclAsType(FunctionalChain)->map globalAlternatesOnFC_SF32globalAlternatesOnFC_SF();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InstanceRole.oclAsType(EClass)).oclAsType(InstanceRole)->map nonRentrantSCenario32nonRentrantSCenario();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SequenceMessage.oclAsType(EClass)).oclAsType(SequenceMessage)->map instantaneousReply32instantaneousReply();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SequenceMessage.oclAsType(EClass)).oclAsType(SequenceMessage)->map causalityCall32causalityCall();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SequenceMessage.oclAsType(EClass)).oclAsType(SequenceMessage)->map forceORderToEaseUnderstanding32forceORderToEaseUnderstanding();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map instantaneousIfNoFunctions32instantaneousIfNoFunctions();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map NonInstantaneousIfNoFunctions32NonInstantaneousIfNoFunctions();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map forceORder32forceORder();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map startsWhenEndOccurs32startsWhenEndOccurs();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map stopsWhenEndOccurs32stopsWhenEndOccurs();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map endsBeforeNextmessageSending42endsBeforeNextmessageSending();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map endsBeforeNextmessageSending242endsBeforeNextmessageSending2();
		
	}





//create the expressions...

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM6::Mode::intermediate_allFiredoutgoingTransition2Expression(an1 : StateTransition, an2 : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFiredoutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM6::Mode::intermediate_allFiredoutgoingTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFiredoutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fire']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM6::Mode::allFiredoutgoingTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(StateTransition) := self.oclAsType(ecore::EObject).eContainer().oclAsType(Region).ownedTransitions-> select (t | t.source = self)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allFiredoutgoingTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allFiredoutgoingTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allFiredoutgoingTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM6::Mode::intermediate_allInputTransition2Expression(an1 : StateTransition, an2 : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM6::Mode::intermediate_allInputTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fire']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM6::Mode::allInputTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(StateTransition) := self.oclAsType(ecore::EObject).eContainer().oclAsType(Region).ownedTransitions-> select (t | t.target = self)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allInputTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM6::StateMachine::onlyOneFirst2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_OneTickAndNoMore_onlyOneFirst';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'OneTickAndNoMoreClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'OneTickAndNoMore']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::System::intermediate_allStartMachine2Expression(an1 : StateMachine, an2 : StateMachine, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartMachine'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_start']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_start']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::System::intermediate_allStartMachine2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateMachine, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartMachine'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_start']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::System::allStartMachine2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(StateMachine) := self.ownedStateMachines->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allStartMachine2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allStartMachine2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allStartMachine2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM7::System::onlyOneFirst2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_OneTickAndNoMore_onlyOneFirst';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'OneTickAndNoMoreClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'OneTickAndNoMore']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM8::ExchangeItem::intermediate_raisingTransitionFiring2Expression(an1 : StateTransition, an2 : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_raisingTransitionFiring'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
				allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM8::ExchangeItem::intermediate_raisingTransitionFiring2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_raisingTransitionFiring'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
				allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fire']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM8::ExchangeItem::raisingTransitionFiring2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
				allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(StateTransition) := raisingTransitions->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_raisingTransitionFiring2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_raisingTransitionFiring2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_raisingTransitionFiring2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM8::ExchangeItem::intermediate_allRelatedMessages2Expression(an1 : MessageEnd, an2 : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allRelatedMessages'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
				allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM8::ExchangeItem::intermediate_allRelatedMessages2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allRelatedMessages'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
				allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_occurs']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM8::ExchangeItem::allRelatedMessages2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
				allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
						.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(MessageEnd) := raisingMessages.sendingEnd->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allRelatedMessages2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allRelatedMessages2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allRelatedMessages2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM9::SystemFunction::intermediate_allAssociatedModeEntering2Expression(an1 : Mode, an2 : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAssociatedModeEntering'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
		    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_entering']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_entering']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM9::SystemFunction::intermediate_allAssociatedModeEntering2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAssociatedModeEntering'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
		    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_entering']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM9::SystemFunction::allAssociatedModeEntering2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
		    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(Mode) := allRelatedModes->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allAssociatedModeEntering2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allAssociatedModeEntering2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allAssociatedModeEntering2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM9::SystemFunction::intermediate_allAssociatedModeLeaving2Expression(an1 : Mode, an2 : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAssociatedModeLeaving'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
		    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_leaving']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_leaving']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM9::SystemFunction::intermediate_allAssociatedModeLeaving2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAssociatedModeLeaving'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
		    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_leaving']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM9::SystemFunction::allAssociatedModeLeaving2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
		    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(Mode) := allRelatedModes->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allAssociatedModeLeaving2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allAssociatedModeLeaving2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allAssociatedModeLeaving2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM10::FunctionalExchange::intermediate_relatedModeLeaving2Expression(an1 : Mode, an2 : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_relatedModeLeaving'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
		    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_leaving']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_leaving']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM10::FunctionalExchange::intermediate_relatedModeLeaving2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_relatedModeLeaving'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
		    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_leaving']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM10::FunctionalExchange::relatedModeLeaving2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
		    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(Mode) := allRelatedModes->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_relatedModeLeaving2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_relatedModeLeaving2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_relatedModeLeaving2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM10::FunctionalExchange::intermediate_relatedModeEntering2Expression(an1 : Mode, an2 : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_relatedModeEntering'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
		    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_entering']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_entering']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM10::FunctionalExchange::intermediate_relatedModeEntering2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_relatedModeEntering'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
		    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_entering']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM10::FunctionalExchange::relatedModeEntering2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
		    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
				allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(Mode) := allRelatedModes->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_relatedModeEntering2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_relatedModeEntering2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_relatedModeEntering2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM10::FunctionOutputPort::intermediate_associatedStateLeaving2Expression(an1 : Mode, an2 : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_associatedStateLeaving'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_leaving']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_leaving']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM10::FunctionOutputPort::intermediate_associatedStateLeaving2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_associatedStateLeaving'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_leaving']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM10::FunctionOutputPort::associatedStateLeaving2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(Mode) := self.oclAsType(ecore::EObject).eContainer().eContainer().oclAsType(ctx::SystemFunction).ownedFunctionalChains->select(fc|fc.oclAsType(fa::FunctionalChain).enactedFunctions->select(ef | ef = self.oclAsType(ecore::EObject).eContainer())->size() > 0).availableInStates.oclAsType(capellacommon::Mode)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_associatedStateLeaving2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_associatedStateLeaving2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_associatedStateLeaving2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM10::FunctionOutputPort::intermediate_associatedStateEntering2Expression(an1 : Mode, an2 : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_associatedStateEntering'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_entering']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_entering']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM10::FunctionOutputPort::intermediate_associatedStateEntering2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Mode, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_associatedStateEntering'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_entering']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM10::FunctionOutputPort::associatedStateEntering2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(Mode) := self.oclAsType(ecore::EObject).eContainer().eContainer().oclAsType(ctx::SystemFunction).ownedFunctionalChains->select(fc|fc.oclAsType(fa::FunctionalChain).enactedFunctions->select(ef | ef = self.oclAsType(ecore::EObject).eContainer())->size() > 0).availableInStates.oclAsType(capellacommon::Mode)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_associatedStateEntering2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_associatedStateEntering2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_associatedStateEntering2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}




	 	mapping inMM3::AbstractEnd::occurs2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_occurs';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_occurs';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM4::ExchangeItem::occurs2Clock() :TimeModel::Clock 
			when { (self.exchangeMechanism = ExchangeMechanism::EVENT) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_occurs';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_occurs';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM5::SystemFunction::enacts2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_enacts';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_enacts';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM5::SystemFunction::unEnacts2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_unEnacts';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_unEnacts';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM5::SystemFunction::starts2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_starts';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_starts';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM5::SystemFunction::stops2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_stops';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_stops';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM5::System::start2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_start';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_start';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM6::Mode::entering2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_entering';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_entering';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM6::Mode::leaving2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_leaving';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_leaving';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM6::StateMachine::start2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_start';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_start';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM6::StateTransition::fire2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_fire';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_fire';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM6::StateTransition::TAGshare42TAGshare(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
			  let triggerIsShare : Boolean = self.oclAsType(ecore::EObject).eContainer().eContainer().oclAsType(capellacommon::StateMachine).ownedRegions.ownedTransitions->select(t | t.triggers->size() > 0 and t.triggers->first() <> null and t.triggers->first() = self.triggers->first() )->size() > 0 in
				( self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and self.triggers->size() > 0
			  and self.source.oclIsKindOf(Mode)
			  and self.target.oclIsKindOf(Mode)
			  and triggerIsShare
			) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"TriggerOnlyTransition_TAGshare";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TriggerOnlyTransition")->first();
					var triggerIsShare : Boolean := self.oclAsType(ecore::EObject).eContainer().eContainer().oclAsType(capellacommon::StateMachine).ownedRegions.ownedTransitions->select(t | t.triggers->size() > 0 and t.triggers->first() <> null and t.triggers->first() = self.triggers->first() )->size() > 0;
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(Mode).oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_stateEntry']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_fire']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_trigger']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(--triggers->first().oclAsType(information::ExchangeItem).occurs,
		 							self.source.oclAsType(Mode).oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_reset']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_fire']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_fire']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::StateTransition::TAGsNotSare42TAGsNotSare(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
			  let triggerIsShare : Boolean = self.oclAsType(ecore::EObject).eContainer().eContainer().oclAsType(capellacommon::StateMachine).ownedRegions.ownedTransitions->select(t | t.triggers->size() > 0 and t.triggers->first() <> null and t.triggers->first() = self.triggers->first() )->size() > 0 in
				( self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and self.triggers->size() > 0
			  and self.source.oclIsKindOf(Mode)
			  and self.target.oclIsKindOf(Mode)
			  and triggerIsShare
			) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"TriggerOnlyTransition_TAGsNotSare";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TriggerOnlyTransition")->first();
					var triggerIsShare : Boolean := self.oclAsType(ecore::EObject).eContainer().eContainer().oclAsType(capellacommon::StateMachine).ownedRegions.ownedTransitions->select(t | t.triggers->size() > 0 and t.triggers->first() <> null and t.triggers->first() = self.triggers->first() )->size() > 0;
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(Mode).oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_stateEntry']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.triggers->first().oclAsType(information::ExchangeItem).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_trigger']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(Mode).oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_reset']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_fire']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_fire']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM6::Mode::enterOnceBeforeToLeave32enterOnceBeforeToLeave(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"WeakAlternates_enterOnceBeforeToLeave";
			type := seqOfRelationDeclaration->select(rd | rd.name = "WeakAlternates")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::Mode::firingATransitionMeansLeavingState32firingATransitionMeansLeavingState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and self.oclAsType(ecore::EObject).eContainer().oclAsType(Region).ownedTransitions-> select (t | t.source = self)->size() > 0
			) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firingATransitionMeansLeavingState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allFiredoutgoingTransition2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::Mode::stateEntering132stateEntering1(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and not (self.oclIsTypeOf(InitialPseudoState)) 
			  and self.oclAsType(ecore::EObject).eContainer().oclAsType(Region).ownedTransitions-> select (t | t.target = self)->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_stateEntering1";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allInputTransition2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM6::Mode::intermediate_oneTransitionAtATime32oneTransitionAtATime(an1 : StateTransition, an2 : StateTransition, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneTransitionAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
						_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM6::Mode::oneTransitionAtATime32oneTransitionAtATime()
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and self.oclAsType(ecore::EObject).eContainer().oclAsType(Region).ownedTransitions-> select (t | t.source = self)->size() > 1
			) }
	{
		init{
			
			var sources : Sequence(StateTransition) := self.oclAsType(ecore::EObject).eContainer().oclAsType(Region).ownedTransitions-> select (t | t.source = self)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneTransitionAtATime32oneTransitionAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		

//relation stuff		
	
		mapping inMM6::StateMachine::firstIsInitialState32firstIsInitialState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedRegions->first().ownedTransitions->select(t | t.source =self.ownedRegions->first().ownedStates->select(e | e.oclIsKindOf(InitialPseudoState))->first())->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firstIsInitialState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.ownedRegions->first().ownedTransitions->select(t | t.source =self.ownedRegions->first().ownedStates->select(e | e.oclIsKindOf(InitialPseudoState))->first())->first().oclAsType(EObject))+'_fire']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::StateMachine::firstOnlyOnce22firstOnlyOnce(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firstOnlyOnce";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map onlyOneFirst2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM7::System::startTimedSystemBeforeAllStartComponent32startTimedSystemBeforeAllStartComponent(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedStateMachines->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_startTimedSystemBeforeAllStartComponent";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allStartMachine2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM7::System::intermediate_allStartsTogether32allStartsTogether(an1 : StateMachine, an2 : StateMachine, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartsTogether'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Coincidence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_start']->first();
						_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_start']->first();
						_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM7::System::allStartsTogether32allStartsTogether()
			when { (self.ownedStateMachines->size() > 1) }
	{
		init{
			
			var sources : Sequence(StateMachine) := self.ownedStateMachines->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_allStartsTogether32allStartsTogether(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM7::System::firstOnlyOnce22firstOnlyOnce(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firstOnlyOnce";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map onlyOneFirst2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM8::ExchangeItem::occursWhenFireIfInEffects42occursWhenFireIfInEffects(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let raisingTransitions : Collection(capellacommon::StateTransition) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
				.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition) in
		      let raisingMessages : Collection(interaction::SequenceMessage) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
				.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage) in
				(raisingTransitions->size() > 0 and self.exchangeMechanism = ExchangeMechanism::EVENT) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_occursWhenFireIfInEffects";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
							.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
					allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
							.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map raisingTransitionFiring2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM8::ExchangeItem::occursWhenAnyMEssageSent42occursWhenAnyMEssageSent(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let raisingTransitions : Collection(capellacommon::StateTransition) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
				.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition) in
		      let raisingMessages : Collection(interaction::SequenceMessage) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
				.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage) in
				(raisingMessages->size() > 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_occursWhenAnyMEssageSent";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
							.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
					allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
							.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allRelatedMessages2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM8::ExchangeItem::ifExchangeItemItOccurs32ifExchangeItemItOccurs(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let raisingTransitions : Collection(capellacommon::StateTransition) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
				.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition) in
		      let raisingMessages : Collection(interaction::SequenceMessage) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
				.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage) in
				(raisingMessages->size() = 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_ifExchangeItemItOccurs";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var raisingTransitions : Collection(capellacommon::StateTransition) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
							.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(capellacommon::StateTransition))->select(t | t.oclAsType(capellacommon::StateTransition).effect->exists(f | f = self)).oclAsType(capellacommon::StateTransition);
					allVarDefs->append("ExchangeItem::raisingTransitions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var raisingMessages : Collection(interaction::SequenceMessage) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
							.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->select(e | e.oclIsKindOf(interaction::SequenceMessage) and e.oclAsType(interaction::SequenceMessage).exchangedItems->size() > 0 and e.oclAsType(interaction::SequenceMessage).exchangedItems->first()=self ).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("ExchangeItem::raisingMessages"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(raisingMessages->asSequence()->first().sendingEnd.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM9::SystemFunction::taskTaskInv32taskTaskInv(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allRelatedModes : Collection(capellacommon::Mode) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode) in
				(self.ownedFunctions->isEmpty()) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"DesactivableAlternates_taskTaskInv";
			type := seqOfRelationDeclaration->select(rd | rd.name = "DesactivableAlternates")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
			    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
					allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'DesactivableAlternates_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfAbstractEntity[name = 'DesactivableAlternates_right']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_enacts']->first();
					_abstract := seqOfAbstractEntity[name = 'DesactivableAlternates_enable']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unEnacts']->first();
					_abstract := seqOfAbstractEntity[name = 'DesactivableAlternates_disable']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM9::SystemFunction::EnactedByAssociatedModeEntering42EnactedByAssociatedModeEntering(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allRelatedModes : Collection(capellacommon::Mode) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode) in
				(allRelatedModes->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_EnactedByAssociatedModeEntering";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
			    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
					allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_enacts']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allAssociatedModeEntering2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM9::SystemFunction::UnEnactedByAssociatedModeLeaving42UnEnactedByAssociatedModeLeaving(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allRelatedModes : Collection(capellacommon::Mode) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode) in
				(allRelatedModes->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_UnEnactedByAssociatedModeLeaving";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis)
			    		.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).enactedFunctions->exists(f | f = self)).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
					allVarDefs->append("SystemFunction::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unEnacts']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allAssociatedModeLeaving2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM10::FunctionalExchange::ConditionalAlternatesRelationFromFunctionalExchanges42ConditionalAlternatesRelationFromFunctionalExchanges(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let allRelatedModes : Collection(capellacommon::Mode) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode) in
				(allRelatedModes->size() > 0 and self.source.oclAsType(ecore::EObject).eContainer().oclIsKindOf(ctx::SystemFunction)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesOrFree_ConditionalAlternatesRelationFromFunctionalExchanges";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesOrFree")->first();
					var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
					allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.target.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_right']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map relatedModeEntering2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_enable']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map relatedModeLeaving2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_disable']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM10::FunctionalExchange::AlternatesRelationFromFunctionalExchanges32AlternatesRelationFromFunctionalExchanges(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let allRelatedModes : Collection(capellacommon::Mode) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode) in
				(allRelatedModes->size() = 0 and self.source.oclAsType(ecore::EObject).eContainer().oclIsKindOf(ctx::SystemFunction)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_AlternatesRelationFromFunctionalExchanges";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
					var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
					allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.target.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM10::FunctionalExchange::eventExchangeItemCanOccurOnlyInDedicatedContext32eventExchangeItemCanOccurOnlyInDedicatedContext(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let allRelatedModes : Collection(capellacommon::Mode) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode) in
				(self.exchangedItems->size() > 0 and self.exchangedItems->first().exchangeMechanism = ExchangeMechanism::EVENT) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Causes_eventExchangeItemCanOccurOnlyInDedicatedContext";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
					var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
					allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.exchangedItems->first().oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.target.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM10::FunctionalExchange::eventExchangeItemCanOccurOnlyInDedicatedContext232eventExchangeItemCanOccurOnlyInDedicatedContext2(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let allRelatedModes : Collection(capellacommon::Mode) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode) in
				(self.exchangedItems->size() > 0 and self.exchangedItems->first().exchangeMechanism = ExchangeMechanism::EVENT) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_eventExchangeItemCanOccurOnlyInDedicatedContext2";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
					var allRelatedModes : Collection(capellacommon::Mode) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			    	.oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(fa::FunctionalChain))->select(m | m.oclAsType(fa::FunctionalChain).involvedFunctionalExchanges->exists(f | f = self) or self = m.oclAsType(fa::FunctionalChain).firstFunctionalChainInvolvements.involvedElement->first()).oclAsType(fa::FunctionalChain).availableInStates.oclAsType(capellacommon::Mode);
					allVarDefs->append("FunctionalExchange::allRelatedModes"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.exchangedItems->first().oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM10::FunctionOutputPort::outputPortsWithEventCanOccurDuringFunctionExecution52outputPortsWithEventCanOccurDuringFunctionExecution(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.outgoingExchangeItems->size() > 0 and self.outgoingExchangeItems->first().exchangeMechanism = ExchangeMechanism::EVENT) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"ContextualEvent_outputPortsWithEventCanOccurDuringFunctionExecution";
			type := seqOfRelationDeclaration->select(rd | rd.name = "ContextualEvent")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.outgoingExchangeItems->first().oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'ContextualEvent_occurs']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'ContextualEvent_enabler']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfAbstractEntity[name = 'ContextualEvent_disabler']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map associatedStateEntering2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'ContextualEvent_FCenabler']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map associatedStateLeaving2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'ContextualEvent_FCdisabler']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM10::FunctionalChain::globalAlternatesOnFC32globalAlternatesOnFC(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.involvedElements->first().oclIsKindOf(FunctionalExchange)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesOrFree_globalAlternatesOnFC";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesOrFree")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.involvedElements->first().oclAsType(FunctionalExchange).source.oclAsType(ecore::EObject).eContainer().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.firstFunctionalChainInvolvements->last().involved.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_right']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.availableInStates.oclAsType(capellacommon::Mode)->first().oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_enable']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.availableInStates.oclAsType(capellacommon::Mode)->first().oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_disable']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM10::FunctionalChain::globalAlternatesOnFC_SF32globalAlternatesOnFC_SF(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.involvedElements->first().oclIsKindOf(ctx::SystemFunction)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AlternatesOrFree_globalAlternatesOnFC_SF";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AlternatesOrFree")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.involvedElements->first().oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_left']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.firstFunctionalChainInvolvements->last().involved.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_right']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.availableInStates.oclAsType(capellacommon::Mode)->first().oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_enable']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.availableInStates.oclAsType(capellacommon::Mode)->first().oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesOrFree_disable']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM11::InstanceRole::nonRentrantSCenario32nonRentrantSCenario(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.abstractEnds->size() > 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_nonRentrantSCenario";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.abstractEnds->first().oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.abstractEnds->last().oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM11::SequenceMessage::instantaneousReply32instantaneousReply(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.kind = MessageKind::REPLY) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_instantaneousReply";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.sendingEnd.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.receivingEnd.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::SequenceMessage::causalityCall32causalityCall(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.kind <> MessageKind::REPLY) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_causalityCall";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.sendingEnd.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.receivingEnd.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::SequenceMessage::forceORderToEaseUnderstanding32forceORderToEaseUnderstanding(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.sendingEnd.covered <> self.receivingEnd.covered and self.sendingEnd.covered.abstractEnds->size() > (self.sendingEnd.covered.abstractEnds->indexOf(self.sendingEnd)+1)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_forceORderToEaseUnderstanding";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.receivingEnd.oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.sendingEnd.covered.abstractEnds->at(self.sendingEnd.covered.abstractEnds->indexOf(self.sendingEnd)+1).oclAsType(MessageEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM11::Execution::instantaneousIfNoFunctions32instantaneousIfNoFunctions(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let correspondingFunctions : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name ) in
				(correspondingFunctions->size() = 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_instantaneousIfNoFunctions";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var correspondingFunctions : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name );
					allVarDefs->append("Execution::correspondingFunctions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::Execution::NonInstantaneousIfNoFunctions32NonInstantaneousIfNoFunctions(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let correspondingFunctions : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name ) in
				(correspondingFunctions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_NonInstantaneousIfNoFunctions";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
					var correspondingFunctions : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name );
					allVarDefs->append("Execution::correspondingFunctions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::Execution::forceORder32forceORder(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let correspondingFunctions : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name ) in
				(correspondingFunctions->size() > 0 and self.start.oclAsType(AbstractEnd).covered.abstractEnds->size() > (self.start.oclAsType(AbstractEnd).covered.abstractEnds->indexOf(self.start)+1)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_forceORder";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
					var correspondingFunctions : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name );
					allVarDefs->append("Execution::correspondingFunctions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).covered.abstractEnds->at(self.start.oclAsType(AbstractEnd).covered.abstractEnds->indexOf(self.start)+1).oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::Execution::startsWhenEndOccurs32startsWhenEndOccurs(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let correspondingFunctions : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name ) in
				(correspondingFunctions->size() = 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_startsWhenEndOccurs";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var correspondingFunctions : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name );
					allVarDefs->append("Execution::correspondingFunctions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(correspondingFunctions->asSequence()->first().oclAsType(EObject))+'_starts']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::Execution::stopsWhenEndOccurs32stopsWhenEndOccurs(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let correspondingFunctions : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name ) in
				(correspondingFunctions->size() = 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_stopsWhenEndOccurs";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var correspondingFunctions : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name );
					allVarDefs->append("Execution::correspondingFunctions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(correspondingFunctions->asSequence()->first().oclAsType(EObject))+'_stops']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::Execution::endsBeforeNextmessageSending42endsBeforeNextmessageSending(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
			  let associatedMessage : SequenceMessage = self.start.oclAsType(ecore::EObject).eCrossReferences()->select(cr |cr.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->asSequence()->first() in
		      let correspondingFunctions : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name ) in
				(associatedMessage.sendingEnd.covered <> associatedMessage.receivingEnd.covered and associatedMessage.sendingEnd.covered.abstractEnds->size() > (associatedMessage.sendingEnd.covered.abstractEnds->indexOf(associatedMessage.sendingEnd)+1)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_endsBeforeNextmessageSending";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
					var associatedMessage : SequenceMessage := self.start.oclAsType(ecore::EObject).eCrossReferences()->select(cr |cr.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->asSequence()->first();
					var correspondingFunctions : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name );
					allVarDefs->append("Execution::correspondingFunctions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(associatedMessage.sendingEnd.covered.abstractEnds->at(associatedMessage.sendingEnd.covered.abstractEnds->indexOf(associatedMessage.sendingEnd)+1).oclAsType(MessageEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM11::Execution::endsBeforeNextmessageSending242endsBeforeNextmessageSending2(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
			  let associatedMessage : SequenceMessage = self.start.oclAsType(ecore::EObject).eCrossReferences()->select(cr |cr.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->asSequence()->first() in
		      let correspondingFunctions : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name ) in
				(associatedMessage.sendingEnd.covered = associatedMessage.receivingEnd.covered and self.covered.abstractEnds->size() > (self.covered.abstractEnds->indexOf(self.finish)+1)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_endsBeforeNextmessageSending2";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
					var associatedMessage : SequenceMessage := self.start.oclAsType(ecore::EObject).eCrossReferences()->select(cr |cr.oclIsKindOf(interaction::SequenceMessage)).oclAsType(interaction::SequenceMessage)->asSequence()->first();
					var correspondingFunctions : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(ctx::SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(ctx::SystemAnalysis))->asSequence()->first().oclAsType(ctx::SystemAnalysis)
			        .oclAsType(ecore::EObject)->closure(e | e.eContents().oclAsType(ecore::EObject))->select(eo |eo.oclIsKindOf(ctx::SystemFunction)).oclAsType(ctx::SystemFunction)->select(sf | sf.name = self.name );
					allVarDefs->append("Execution::correspondingFunctions"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.covered.abstractEnds->at(self.covered.abstractEnds->indexOf(self.finish)+1).oclAsType(AbstractEnd).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		





















mapping inMM1::Project::capellamodeller2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
		}; 
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), AbstractEnd.oclAsType(EClass)).oclAsType(AbstractEnd)->map occurs2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ExchangeItem.oclAsType(EClass)).oclAsType(ExchangeItem)->map occurs2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map enacts2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map unEnacts2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map starts2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map stops2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map start2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map entering2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map leaving2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map start2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateTransition.oclAsType(EClass)).oclAsType(StateTransition)->map fire2MSE();
}		


	 	mapping inMM3::AbstractEnd::occurs2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_occurs';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_occurs')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM4::ExchangeItem::occurs2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.exchangeMechanism = ExchangeMechanism::EVENT) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_occurs';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_occurs')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM5::SystemFunction::enacts2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_enacts';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_enacts')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM5::SystemFunction::unEnacts2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_unEnacts';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_unEnacts')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM5::SystemFunction::starts2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_starts';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_starts')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM5::SystemFunction::stops2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_stops';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_stops')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM5::System::start2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_start';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_start')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::Mode::entering2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_entering';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_entering')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::Mode::leaving2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_leaving';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_leaving')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::StateMachine::start2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_start';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_start')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::StateTransition::fire2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_fire';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_fire')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
			
		






//priority stuff

mapping inMM1::Project::capellamodeller2Priority()  :Priority::PrioritySpecification  {
	thePrioritySpec := result;
	importedModel := object Priority::ImportStatement{
		importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
	}; 
}	




