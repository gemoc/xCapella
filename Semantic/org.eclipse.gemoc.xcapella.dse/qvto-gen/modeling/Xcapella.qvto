import org.eclipse.gemoc.moccml_mapping.EclQVToHelper;
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
	modeltype inMM1 uses 'http://www.polarsys.org/capella/core/modeller/1.3.0';
	modeltype inMM2 uses 'http://www.polarsys.org/capella/core/fa/1.3.0';
	modeltype inMM3 uses 'http://www.polarsys.org/capella/core/ctx/1.3.0';
	modeltype inMM4 uses 'http://www.polarsys.org/capella/core/common/1.3.0';
	modeltype inMM5 uses 'http://www.polarsys.org/capella/core/ctx/1.3.0';
	modeltype inMM6 uses 'http://www.polarsys.org/capella/core/interaction/1.3.0';
	modeltype inMM7 uses 'http://www.polarsys.org/capella/core/ctx/1.3.0';

modeltype QVT 		uses 'http://www.eclipse.org/QVT/1.0.0/Operational';
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';
modeltype FeedBack 	uses 'http://timesquare.inria.fr/feedback';
modeltype Priority  uses 'http://fr.inria.aoste.timesquare.ccslkernel.solver.priorities';


transformation docapellamodeller_To_CCSL(in inM : inMM1, out ccsl : TimeModel, out feedback : FeedBack, out priority: Priority);

property thePrioritySpec		:Priority::PrioritySpecification = null;
property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};
property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;
property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;
property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};
property allVarDefs : Sequence(String) = Sequence{}; 

query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map capellamodeller2CCSL();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map capellamodeller2FeedBack();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map capellamodeller2Priority();
}

			
	mapping inMM1::Project::capellamodeller2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/lib4RT.ccslLib';
			alias := 'lib4RT';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/temporalConstraints.moccml';
			alias := 'temporalConstraints';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoC.ccslLib';
			alias := 'SMCubeMoC';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.xcapella.mocc/mocc/SMCubeMoCC.moccml';
			alias := 'SMCubeMoCC';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map activated2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map started2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map terminated2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map suspended2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map unsuspend2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map isRunning2Clock();
		////[ SystemFunction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map hasBeenElected2Clock();
		


		

		////[ System ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map isWorking2Clock();
		////[ System ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map start2Clock();
		


		

		////[ SystemAnalysis ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemAnalysis.oclAsType(EClass)).oclAsType(SystemAnalysis)->map ms2Clock();
		


		

		////[ ChangeEvent ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ChangeEvent.oclAsType(EClass)).oclAsType(ChangeEvent)->map occurs2Clock();
		


		

		////[ Mode ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map entering2Clock();
		////[ Mode ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map leaving2Clock();
		


		

		////[ StateMachine ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map start2Clock();
		////[ StateMachine ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map anyEventOrTime2Clock();
		


		

		////[ StateTransition ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateTransition.oclAsType(EClass)).oclAsType(StateTransition)->map fire2Clock();
		


		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateTransition.oclAsType(EClass)).oclAsType(StateTransition)->map TAG32TAG();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map enterOnceBeforeToLeave32enterOnceBeforeToLeave();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map firingATransitionAlternatesWithLeavingState32firingATransitionAlternatesWithLeavingState();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map stateEntering132stateEntering1();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map stateEntering_microstep132stateEntering_microstep1();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map oneTransitionAtATime32oneTransitionAtATime();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map oneModeAtATime22oneModeAtATime();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map defineAllEventOrTime32defineAllEventOrTime();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map firstIsInitialState32firstIsInitialState();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map firstOnlyOnce22firstOnlyOnce();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map startTimedSystemBeforeAllStartComponent32startTimedSystemBeforeAllStartComponent();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map allStartsTogether32allStartsTogether();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map firstOnlyOnce22firstOnlyOnce();
		
		

		////[ AbstractEnd ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), AbstractEnd.oclAsType(EClass)).oclAsType(AbstractEnd)->map abstractEnd_occurs2Clock();
		


		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InstanceRole.oclAsType(EClass)).oclAsType(InstanceRole)->map endsInOrder12endsInOrder();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InstanceRole.oclAsType(EClass)).oclAsType(InstanceRole)->map nonRentrantSCenario32nonRentrantSCenario();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SequenceMessage.oclAsType(EClass)).oclAsType(SequenceMessage)->map instantaneousReply32instantaneousReply();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SequenceMessage.oclAsType(EClass)).oclAsType(SequenceMessage)->map causalityCall32causalityCall();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SequenceMessage.oclAsType(EClass)).oclAsType(SequenceMessage)->map sendMeansActivates32sendMeansActivates();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map eitherElectedXORmessageOccured22eitherElectedXORmessageOccured();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map startedOrrElectedMeansStarts42startedOrrElectedMeansStarts();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map stopWhenEndOccurs22stopWhenEndOccurs();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Execution.oclAsType(EClass)).oclAsType(Execution)->map startBeforeFinish_nonRentrant12startBeforeFinish_nonRentrant();
		
		

		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map isPeriodic2Integer();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map periodValue2Integer();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map offsetValue2Integer();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map firstValue2Integer();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map secondValue2Integer();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map isAllocatedWithOthers2Integer();
		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map DurationAsAPeriodic32DurationAsAPeriodic();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map DurationOfAllocatedExec32DurationOfAllocatedExec();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map DurationOfNonAllocatedExec32DurationOfNonAllocatedExec();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ConstraintDuration.oclAsType(EClass)).oclAsType(ConstraintDuration)->map DurationOfZero32DurationOfZero();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map nonPreemptiveSched_part232nonPreemptiveSched_part2();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map isWorkingIfATaskIsRunning42isWorkingIfATaskIsRunning();
		
		

		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map isAllocatedWithOthers2Integer();
		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map unsuspendBeforeElection32unsuspendBeforeElection();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map taskTaskInv32taskTaskInv();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map isRunningTakesTime32isRunningTakesTime();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map SuspendIfAnotherStartOnSameCPUOrSendSynchCall72SuspendIfAnotherStartOnSameCPUOrSendSynchCall();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map SuspendIfAnotherStartOnSameCPU52SuspendIfAnotherStartOnSameCPU();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map SuspendIfSendSynchCall52SuspendIfSendSynchCall();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map NeverSuspend32NeverSuspend();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map UnSuspendIfAnotherTerminateOnSameCPUorReceiveSynchCall82UnSuspendIfAnotherTerminateOnSameCPUorReceiveSynchCall();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map UnSuspendIfAnotherTerminateOnSameCPU42UnSuspendIfAnotherTerminateOnSameCPU();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map UnSuspendIfReceiveSynchCall42UnSuspendIfReceiveSynchCall();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map NeverUnsuspend32NeverUnsuspend();
		
	}





//create the expressions...

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM4::Mode::intermediate_allFiredoutgoingTransition2Expression(an1 : StateTransition, an2 : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFiredoutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM4::Mode::intermediate_allFiredoutgoingTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFiredoutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fire']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM4::Mode::allFiredoutgoingTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(StateTransition) := self.outgoing->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allFiredoutgoingTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allFiredoutgoingTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allFiredoutgoingTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM4::Mode::intermediate_allInputTransition2Expression(an1 : StateTransition, an2 : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM4::Mode::intermediate_allInputTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fire']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM4::Mode::allInputTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(StateTransition) := self.incoming->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allInputTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM4::Mode::intermediate_allFire12Expression(an1 : StateTransition, an2 : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFire1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM4::Mode::intermediate_allFire12Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateTransition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allFire1'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fire']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM4::Mode::allFire12Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(StateTransition) := self.incoming->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allFire12Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allFire12Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allFire12Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM4::StateMachine::intermediate_allEvents2Expression(an1 : ChangeEvent, an2 : ChangeEvent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allEvents'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM4::StateMachine::intermediate_allEvents2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : ChangeEvent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allEvents'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_occurs']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM4::StateMachine::allEvents2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(ChangeEvent) := self.ownedRegions.ownedTransitions->select(t| t.triggers->size() > 0 and t.triggers->first().oclIsKindOf(ChangeEvent)).triggers->first().oclAsType(ChangeEvent)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allEvents2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allEvents2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allEvents2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM4::StateMachine::onlyOneFirst2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_OneTickAndNoMore_onlyOneFirst';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'OneTickAndNoMoreClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'OneTickAndNoMore']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM5::System::intermediate_allStartMachine2Expression(an1 : StateMachine, an2 : StateMachine, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartMachine'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_start']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_start']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM5::System::intermediate_allStartMachine2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : StateMachine, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartMachine'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_start']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM5::System::allStartMachine2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(StateMachine) := self.oclAsType(ecore::EObject).eAllContents()->select(e | e.oclIsTypeOf(capellacommon::StateMachine)).oclAsType(capellacommon::StateMachine)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allStartMachine2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allStartMachine2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allStartMachine2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM5::System::onlyOneFirst2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_OneTickAndNoMore_onlyOneFirst';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'OneTickAndNoMoreClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'OneTickAndNoMore']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM6::Execution::startedOrElected2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_startedOrElected';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.covered.representedInstance.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_hasBeenElected']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::System::intermediate_aTaskIsRunning2Expression(an1 : SystemFunction, an2 : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_aTaskIsRunning'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_isRunning']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_isRunning']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::System::intermediate_aTaskIsRunning2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_aTaskIsRunning'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_isRunning']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::System::aTaskIsRunning2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

		

		var sources : Sequence(SystemFunction) := self.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_aTaskIsRunning2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_aTaskIsRunning2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_aTaskIsRunning2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM7::SystemFunction::allowers2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allowers';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_started']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::allSuspenders2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allSuspenders';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allOtherStarts2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allSynchronousCalls2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allSynchronousCalls2Expression(an1 : MessageEnd, an2 : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousCalls'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allSynchronousCalls2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousCalls'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allSynchronousCalls2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(MessageEnd) := allSynchCallSet.sendingEnd->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allSynchronousCalls2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allSynchronousCalls2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allSynchronousCalls2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allOtherStarts2Expression(an1 : SystemFunction, an2 : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_started']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_started']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allOtherStarts2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_started']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allOtherStarts2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(SystemFunction) := otherTasks->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allOtherStarts2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allOtherStarts2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allOtherStarts2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM7::SystemFunction::allowers22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allowers2';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_started']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allOtherStarts22Expression(an1 : SystemFunction, an2 : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherStarts2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_started']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_started']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allOtherStarts22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherStarts2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_started']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allOtherStarts22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(SystemFunction) := otherTasks->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allOtherStarts22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allOtherStarts22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allOtherStarts22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM7::SystemFunction::allowers32Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allowers3';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_started']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allSynchronousCalls32Expression(an1 : MessageEnd, an2 : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousCalls3'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allSynchronousCalls32Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousCalls3'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allSynchronousCalls32Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(MessageEnd) := allSynchCallSet.sendingEnd->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allSynchronousCalls32Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allSynchronousCalls32Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allSynchronousCalls32Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM7::SystemFunction::allUnSuspenders2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allUnSuspenders';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allOtherterminated2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allSynchronousReceiveCalls2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allSynchronousReceiveCalls2Expression(an1 : MessageEnd, an2 : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousReceiveCalls'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allSynchronousReceiveCalls2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousReceiveCalls'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allSynchronousReceiveCalls2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(MessageEnd) := allReplySet.receivingEnd->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allSynchronousReceiveCalls2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allSynchronousReceiveCalls2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allSynchronousReceiveCalls2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	mapping inMM7::SystemFunction::allOtherterminatedOrUnsuspend2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_allOtherterminatedOrUnsuspend';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allOtherterminated2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := self -> map allOtherSuspend2Expression()->asSequence()->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allOtherSuspend2Expression(an1 : SystemFunction, an2 : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherSuspend'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_suspended']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_suspended']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allOtherSuspend2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherSuspend'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_suspended']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allOtherSuspend2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(SystemFunction) := otherTasks->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allOtherSuspend2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allOtherSuspend2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allOtherSuspend2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allOtherterminated2Expression(an1 : SystemFunction, an2 : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherterminated'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_terminated']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_terminated']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allOtherterminated2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherterminated'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_terminated']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allOtherterminated2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(SystemFunction) := otherTasks->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allOtherterminated2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allOtherterminated2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allOtherterminated2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allOtherterminated22Expression(an1 : SystemFunction, an2 : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherterminated2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_terminated']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_terminated']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allOtherterminated22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : SystemFunction, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOtherterminated2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_terminated']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allOtherterminated22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(SystemFunction) := otherTasks->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allOtherterminated22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allOtherterminated22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allOtherterminated22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM7::SystemFunction::intermediate_allSynchronousReceiveCalls22Expression(an1 : MessageEnd, an2 : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousReceiveCalls2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		


				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM7::SystemFunction::intermediate_allSynchronousReceiveCalls22Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : MessageEnd, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allSynchronousReceiveCalls2'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM7::SystemFunction::allSynchronousReceiveCalls22Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	

				var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
				allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
						->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
							and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
				 	.oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
							eo.oclIsTypeOf(interaction::SequenceMessage)
							and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
							and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
					).oclAsType(interaction::SequenceMessage);
				allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
				allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
				var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
				allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
		

		var sources : Sequence(MessageEnd) := allReplySet.receivingEnd->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allSynchronousReceiveCalls22Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allSynchronousReceiveCalls22Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allSynchronousReceiveCalls22Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}




	 	mapping inMM3::SystemFunction::activated2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_activated';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_activated';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM3::SystemFunction::started2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_started';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_started';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM3::SystemFunction::terminated2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_terminated';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_terminated';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM3::SystemFunction::suspended2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_suspended';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getFullLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_suspended';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM3::SystemFunction::unsuspend2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_unsuspend';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "destroy")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_unsuspend';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM3::SystemFunction::isRunning2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_isRunning';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_isRunning';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM3::SystemFunction::hasBeenElected2Clock() :TimeModel::Clock 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_hasBeenElected';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_hasBeenElected';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM3::System::isWorking2Clock() :TimeModel::Clock 
			when { (self.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->size() > 0) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_isWorking';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_isWorking';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM3::System::start2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_start';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_start';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM3::SystemAnalysis::ms2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_ms';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_ms';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM4::ChangeEvent::occurs2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_occurs';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_occurs';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM4::Mode::entering2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_entering';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_entering';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM4::Mode::leaving2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_leaving';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_leaving';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM4::StateMachine::start2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_start';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_start';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM4::StateMachine::anyEventOrTime2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_anyEventOrTime';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_anyEventOrTime';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM4::StateTransition::fire2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_fire';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_fire';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM4::StateTransition::TAG32TAG(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				--actually trigger only
			( self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and self.triggers->size() > 0
			  and self.source.oclIsKindOf(Mode)
			  and self.target.oclIsKindOf(Mode)
			) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"TriggerOnlyTransition_TAG";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TriggerOnlyTransition")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(Mode).oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_stateEntry']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.triggers->first().oclAsType(ChangeEvent).oclAsType(EObject))+'_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_trigger']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(Mode).oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_reset']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_fire']->first();
					_abstract := seqOfAbstractEntity[name = 'TOT_fire']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM4::Mode::enterOnceBeforeToLeave32enterOnceBeforeToLeave(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"WeakAlternates_enterOnceBeforeToLeave";
			type := seqOfRelationDeclaration->select(rd | rd.name = "WeakAlternates")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM4::Mode::firingATransitionAlternatesWithLeavingState32firingATransitionAlternatesWithLeavingState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and self.outgoing->size() > 0
--				and (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(cs::Component) )
			) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firingATransitionAlternatesWithLeavingState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allFiredoutgoingTransition2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_leaving']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM4::Mode::stateEntering132stateEntering1(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				--			(not (self = self.oclAsType(ecore::EObject).eContainer().oclAsType(mode::ModeMachine).initial)) implies
			(self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and not (self.oclIsTypeOf(InitialPseudoState)) and self.incoming->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_stateEntering1";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allInputTransition2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM4::Mode::stateEntering_microstep132stateEntering_microstep1(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
		 and (not (self.oclIsTypeOf(InitialPseudoState))) and self.incoming->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"MicroStepConstraint_stateEntering_microstep1";
			type := seqOfRelationDeclaration->select(rd | rd.name = "MicroStepConstraint")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(ecore::EObject).eContainer().eContainer().oclAsType(StateMachine).oclAsType(EObject))+'_anyEventOrTime']->first();
					_abstract := seqOfAbstractEntity[name = 'MSC_eventOrTime']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allFire12Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'MSC_startOfMicroStep']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfAbstractEntity[name = 'MSC_endOfMicroStep']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM4::Mode::intermediate_oneTransitionAtATime32oneTransitionAtATime(an1 : StateTransition, an2 : StateTransition, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneTransitionAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fire']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fire']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM4::Mode::oneTransitionAtATime32oneTransitionAtATime()
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)
			  and self.outgoing->size() > 1
			) }
	{
		init{
			
			var sources : Sequence(StateTransition) := self.outgoing->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneTransitionAtATime32oneTransitionAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		

//relation stuff		
	

//Create an intermediate relation
	mapping inMM4::StateMachine::intermediate_oneModeAtATime22oneModeAtATime(an1 : Mode, an2 : Mode, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneModeAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_entering']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_entering']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM4::StateMachine::oneModeAtATime22oneModeAtATime()
	{
		init{
			
			var sources : Sequence(Mode) := self.ownedRegions.ownedStates->select(s | (s).oclIsKindOf(Mode)).oclAsType(Mode)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneModeAtATime22oneModeAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM4::StateMachine::defineAllEventOrTime32defineAllEventOrTime(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedRegions.ownedTransitions->size() > 0 and self.ownedRegions.ownedTransitions->select(t| t.triggers->size() > 0 and t.triggers->first().oclIsKindOf(ChangeEvent))->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_defineAllEventOrTime";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_anyEventOrTime']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allEvents2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM4::StateMachine::firstIsInitialState32firstIsInitialState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedRegions->first().ownedStates->select(e | e.oclIsKindOf(InitialPseudoState))->first().outgoing->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firstIsInitialState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.ownedRegions->first().ownedStates->select(e | e.oclIsKindOf(InitialPseudoState))->first().outgoing->first().oclAsType(Mode).oclAsType(EObject))+'_entering']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM4::StateMachine::firstOnlyOnce22firstOnlyOnce(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firstOnlyOnce";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map onlyOneFirst2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM5::System::startTimedSystemBeforeAllStartComponent32startTimedSystemBeforeAllStartComponent(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eAllContents()->select(e | e.oclIsTypeOf(capellacommon::StateMachine))->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_startTimedSystemBeforeAllStartComponent";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allStartMachine2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM5::System::intermediate_allStartsTogether32allStartsTogether(an1 : StateMachine, an2 : StateMachine, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allStartsTogether'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Coincidence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_start']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_start']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM5::System::allStartsTogether32allStartsTogether()
			when { (self.oclAsType(ecore::EObject).eAllContents()->select(e | e.oclIsTypeOf(capellacommon::StateMachine))->size() > 1) }
	{
		init{
			
			var sources : Sequence(StateMachine) := self.oclAsType(ecore::EObject).eAllContents()->select(e | e.oclIsTypeOf(capellacommon::StateMachine)).oclAsType(capellacommon::StateMachine)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_allStartsTogether32allStartsTogether(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM5::System::firstOnlyOnce22firstOnlyOnce(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_firstOnlyOnce";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map onlyOneFirst2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	 	mapping inMM6::AbstractEnd::abstractEnd_occurs2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_abstractEnd_occurs';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_abstractEnd_occurs';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	

//Create an intermediate relation
	mapping inMM6::InstanceRole::intermediate_endsInOrder12endsInOrder(an1 : AbstractEnd, an2 : AbstractEnd, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_endsInOrder'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::NonStrictPrecedence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM6::InstanceRole::endsInOrder12endsInOrder()
	{
		init{
			
			var sources : Sequence(AbstractEnd) := self.abstractEnds->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_endsInOrder12endsInOrder(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM6::InstanceRole::nonRentrantSCenario32nonRentrantSCenario(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.abstractEnds->size() > 1) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"WeakAlternates_nonRentrantSCenario";
			type := seqOfRelationDeclaration->select(rd | rd.name = "WeakAlternates")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.abstractEnds->first().oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.abstractEnds->last().oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM6::SequenceMessage::instantaneousReply32instantaneousReply(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.kind = MessageKind::REPLY) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Causes_instantaneousReply";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.sendingEnd.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.receivingEnd.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::SequenceMessage::causalityCall32causalityCall(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.kind <> MessageKind::REPLY) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Causes_causalityCall";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.sendingEnd.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.receivingEnd.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::SequenceMessage::sendMeansActivates32sendMeansActivates(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.kind <> MessageKind::REPLY and self.receivingFunction <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_sendMeansActivates";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.sendingEnd.oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.receivingFunction.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_activated']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM6::Execution::eitherElectedXORmessageOccured22eitherElectedXORmessageOccured(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.covered.representedInstance <> null and self.covered.representedInstance.oclIsTypeOf(ctx::SystemFunction)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_eitherElectedXORmessageOccured";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.covered.representedInstance.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_hasBeenElected']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::Execution::startedOrrElectedMeansStarts42startedOrrElectedMeansStarts(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.covered.representedInstance <> null and self.covered.representedInstance.oclIsTypeOf(ctx::SystemFunction)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_startedOrrElectedMeansStarts";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map startedOrElected2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.covered.representedInstance.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_started']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::Execution::stopWhenEndOccurs22stopWhenEndOccurs(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.covered.representedInstance <> null and self.covered.representedInstance.oclIsTypeOf(ctx::SystemFunction)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_stopWhenEndOccurs";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.covered.representedInstance.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::Execution::startBeforeFinish_nonRentrant12startBeforeFinish_nonRentrant(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"WeakAlternates_startBeforeFinish_nonRentrant";
			type := seqOfRelationDeclaration->select(rd | rd.name = "WeakAlternates")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'weakAlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
		mapping inMM6::ConstraintDuration::isPeriodic2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_isPeriodic';
			type:= Kernel_Integer;
			value := if (self.duration.startsWith('p')) then 1 else 0 endif;

			end{
				theMainBlock.elements += result;
			}
		}
		mapping inMM6::ConstraintDuration::periodValue2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_periodValue';
			type:= Kernel_Integer;
			value := if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;

			end{
				theMainBlock.elements += result;
			}
		}
		mapping inMM6::ConstraintDuration::offsetValue2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_offsetValue';
			type:= Kernel_Integer;
			value := if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;

			end{
				theMainBlock.elements += result;
			}
		}
		mapping inMM6::ConstraintDuration::firstValue2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_firstValue';
			type:= Kernel_Integer;
			value := if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;

			end{
				theMainBlock.elements += result;
			}
		}
		mapping inMM6::ConstraintDuration::secondValue2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_secondValue';
			type:= Kernel_Integer;
			value := if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;

			end{
				theMainBlock.elements += result;
			}
		}
		mapping inMM6::ConstraintDuration::isAllocatedWithOthers2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_isAllocatedWithOthers';
			type:= Kernel_Integer;
			value := if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	
		mapping inMM6::ConstraintDuration::DurationAsAPeriodic32DurationAsAPeriodic(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let isPeriodic : Integer = if (self.duration.startsWith('p')) then 1 else 0 endif in
		      let periodValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let offsetValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let firstValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let secondValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let theSystem : ctx::SystemAnalysis = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis) in
		      let otherTasksOnSameCPU : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance)) in
		      let isAllocatedWithOthers : Integer = if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif in
				(
			isPeriodic = 1
			and 
			periodValue <> 0
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"PeriodicWithJitterUnknowOffset_DurationAsAPeriodic";
			type := seqOfRelationDeclaration->select(rd | rd.name = "PeriodicWithJitterUnknowOffset")->first();
					var isPeriodic : Integer := if (self.duration.startsWith('p')) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isPeriodic"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var periodValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::periodValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var offsetValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::offsetValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var firstValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::firstValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var secondValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::secondValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var theSystem : ctx::SystemAnalysis := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis);
					allVarDefs->append("ConstraintDuration::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasksOnSameCPU : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance));
					allVarDefs->append("ConstraintDuration::otherTasksOnSameCPU"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicWithJitterUnknowOffsetRes']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theSystem.oclAsType(EObject))+'_ms']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicWithJitterUnknowOffsetBase']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_periodValue']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicWithJitterUnknowOffsetPeriod']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_offsetValue']->first();
					_abstract := seqOfAbstractEntity[name = 'PeriodicWithJitterUnknowOffsetJitter']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::ConstraintDuration::DurationOfAllocatedExec32DurationOfAllocatedExec(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let isPeriodic : Integer = if (self.duration.startsWith('p')) then 1 else 0 endif in
		      let periodValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let offsetValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let firstValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let secondValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let theSystem : ctx::SystemAnalysis = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis) in
		      let otherTasksOnSameCPU : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance)) in
		      let isAllocatedWithOthers : Integer = if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif in
				(
			(not (isPeriodic = 1)) 
			and
			firstValue <> 0 
			and
			isAllocatedWithOthers = 1
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Duration_DurationOfAllocatedExec";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Duration")->first();
					var isPeriodic : Integer := if (self.duration.startsWith('p')) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isPeriodic"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var periodValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::periodValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var offsetValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::offsetValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var firstValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::firstValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var secondValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::secondValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var theSystem : ctx::SystemAnalysis := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis);
					allVarDefs->append("ConstraintDuration::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasksOnSameCPU : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance));
					allVarDefs->append("ConstraintDuration::otherTasksOnSameCPU"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'Start']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'End']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).covered.representedInstance.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_isRunning']->first();
					_abstract := seqOfAbstractEntity[name = 'Base']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_firstValue']->first();
					_abstract := seqOfAbstractEntity[name = 'MinValue']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_secondValue']->first();
					_abstract := seqOfAbstractEntity[name = 'MaxValue']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::ConstraintDuration::DurationOfNonAllocatedExec32DurationOfNonAllocatedExec(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let isPeriodic : Integer = if (self.duration.startsWith('p')) then 1 else 0 endif in
		      let periodValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let offsetValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let firstValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let secondValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let theSystem : ctx::SystemAnalysis = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis) in
		      let otherTasksOnSameCPU : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance)) in
		      let isAllocatedWithOthers : Integer = if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif in
				(
			(not (isPeriodic = 1)) 
			and
			firstValue <> 0 
			and
			isAllocatedWithOthers = 0
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Duration_DurationOfNonAllocatedExec";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Duration")->first();
					var isPeriodic : Integer := if (self.duration.startsWith('p')) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isPeriodic"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var periodValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::periodValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var offsetValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::offsetValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var firstValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::firstValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var secondValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::secondValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var theSystem : ctx::SystemAnalysis := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis);
					allVarDefs->append("ConstraintDuration::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasksOnSameCPU : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance));
					allVarDefs->append("ConstraintDuration::otherTasksOnSameCPU"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'Start']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfAbstractEntity[name = 'End']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).covered.representedInstance.oclAsType(ctx::SystemFunction).oclAsType(EObject))+'_isRunning']->first();
					_abstract := seqOfAbstractEntity[name = 'Base']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_firstValue']->first();
					_abstract := seqOfAbstractEntity[name = 'MinValue']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_secondValue']->first();
					_abstract := seqOfAbstractEntity[name = 'MaxValue']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM6::ConstraintDuration::DurationOfZero32DurationOfZero(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let isPeriodic : Integer = if (self.duration.startsWith('p')) then 1 else 0 endif in
		      let periodValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let offsetValue : Integer = if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let firstValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif in
		      let secondValue : Integer = if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif in
		      let theSystem : ctx::SystemAnalysis = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis) in
		      let otherTasksOnSameCPU : Collection(ctx::SystemFunction) = self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance)) in
		      let isAllocatedWithOthers : Integer = if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif in
				( 
			(not (isPeriodic = 1)) 
			and
			firstValue = 0 
			and
			secondValue = 0
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_DurationOfZero";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var isPeriodic : Integer := if (self.duration.startsWith('p')) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isPeriodic"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var periodValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('^..','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::periodValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var offsetValue : Integer := if (self.duration.startsWith('p')) then self.duration.replaceAll('..[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::offsetValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var firstValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('^.','').replaceAll(';.*','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::firstValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var secondValue : Integer := if (not self.duration.startsWith('p')) then self.duration.replaceAll('.[0-9]+;','').replaceAll(']','').toString().toInteger().round() else 0 endif;
					allVarDefs->append("ConstraintDuration::secondValue"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var theSystem : ctx::SystemAnalysis := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis);
					allVarDefs->append("ConstraintDuration::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasksOnSameCPU : Collection(ctx::SystemFunction) := self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().eContents()->select(eo | eo.oclIsKindOf(ctx::System)).oclAsType(ctx::System).ownedFunctionalAllocation.function.oclAsType(ctx::SystemFunction)->select(sf | (sf = self.start.oclAsType(AbstractEnd).covered.representedInstance));
					allVarDefs->append("ConstraintDuration::otherTasksOnSameCPU"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().eContainer().oclAsType(ctx::SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("ConstraintDuration::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.start.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.finish.oclAsType(AbstractEnd).oclAsType(EObject))+'_abstractEnd_occurs']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	

//Create an intermediate relation
	mapping inMM7::System::intermediate_nonPreemptiveSched_part232nonPreemptiveSched_part2(an1 : SystemFunction, an2 : SystemFunction, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_nonPreemptiveSched_part2'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_started']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_started']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM7::System::nonPreemptiveSched_part232nonPreemptiveSched_part2()
			when { (
			self.ownedFunctionalAllocation->size() > 0
		) }
	{
		init{
			
			var sources : Sequence(SystemFunction) := self.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_nonPreemptiveSched_part232nonPreemptiveSched_part2(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM7::System::isWorkingIfATaskIsRunning42isWorkingIfATaskIsRunning(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_isWorkingIfATaskIsRunning";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map aTaskIsRunning2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isWorking']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
		mapping inMM7::SystemFunction::isAllocatedWithOthers2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_isAllocatedWithOthers';
			type:= Kernel_Integer;
			value := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	
		mapping inMM7::SystemFunction::unsuspendBeforeElection32unsuspendBeforeElection(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
	  		self.ownedFunctions->isEmpty()
	  	) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Causes_unsuspendBeforeElection";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Causes")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_hasBeenElected']->first();
					_abstract := seqOfRelationDeclaration[name = 'Causes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::taskTaskInv32taskTaskInv(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"TaskState_taskTaskInv";
			type := seqOfRelationDeclaration->select(rd | rd.name = "TaskState")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_activated']->first();
					_abstract := seqOfAbstractEntity[name = 'TaskStateRealease']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_started']->first();
					_abstract := seqOfAbstractEntity[name = 'TaskStateStart']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfAbstractEntity[name = 'TaskStateStop']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfAbstractEntity[name = 'TaskStateSuspend']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
					_abstract := seqOfAbstractEntity[name = 'TaskStateUnsuspend']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isRunning']->first();
					_abstract := seqOfAbstractEntity[name = 'TaskStateIsRunning']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::isRunningTakesTime32isRunningTakesTime(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SubClock_isRunningTakesTime";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SubClock")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isRunning']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(theSystem.oclAsType(EObject))+'_ms']->first();
					_abstract := seqOfRelationDeclaration[name = 'SubClock']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::SuspendIfAnotherStartOnSameCPUOrSendSynchCall72SuspendIfAnotherStartOnSameCPUOrSendSynchCall(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			allSynchCallSet->size() > 0
			and
			isAllocatedWithOthers = 1
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SuspendOnlyWhenNeeded_SuspendIfAnotherStartOnSameCPUOrSendSynchCall";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SuspendOnlyWhenNeeded")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allSuspenders2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspenders']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendBlockers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allowers2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendAllowers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_suspend']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::SuspendIfAnotherStartOnSameCPU52SuspendIfAnotherStartOnSameCPU(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			allSynchCallSet->size() = 0
			and
			isAllocatedWithOthers = 1
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SuspendOnlyWhenNeeded_SuspendIfAnotherStartOnSameCPU";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SuspendOnlyWhenNeeded")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allOtherStarts22Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspenders']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendBlockers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allowers22Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendAllowers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_suspend']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::SuspendIfSendSynchCall52SuspendIfSendSynchCall(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			allSynchCallSet->size() > 0
			and
			isAllocatedWithOthers = 0
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SuspendOnlyWhenNeeded_SuspendIfSendSynchCall";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SuspendOnlyWhenNeeded")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allSynchronousCalls32Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspenders']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendBlockers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allowers32Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendAllowers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_suspend']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::NeverSuspend32NeverSuspend(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				( 
			allSynchCallSet->size() = 0
			and
			isAllocatedWithOthers = 0
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_NeverSuspend";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::UnSuspendIfAnotherTerminateOnSameCPUorReceiveSynchCall82UnSuspendIfAnotherTerminateOnSameCPUorReceiveSynchCall(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			allReplySet->size() > 0
			and
			isAllocatedWithOthers = 1
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SuspendOnlyWhenNeeded_UnSuspendIfAnotherTerminateOnSameCPUorReceiveSynchCall";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SuspendOnlyWhenNeeded")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allUnSuspenders2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspenders']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendBlockers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendAllowers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_suspend']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::UnSuspendIfAnotherTerminateOnSameCPU42UnSuspendIfAnotherTerminateOnSameCPU(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			allReplySet->size() = 0
			and
			isAllocatedWithOthers = 1
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SuspendOnlyWhenNeeded_UnSuspendIfAnotherTerminateOnSameCPU";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SuspendOnlyWhenNeeded")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allOtherterminated22Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspenders']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendBlockers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendAllowers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_suspend']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::UnSuspendIfReceiveSynchCall42UnSuspendIfReceiveSynchCall(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			allReplySet->size() > 0
			and
			isAllocatedWithOthers = 0
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"SuspendOnlyWhenNeeded_UnSuspendIfReceiveSynchCall";
			type := seqOfRelationDeclaration->select(rd | rd.name = "SuspendOnlyWhenNeeded")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allSynchronousReceiveCalls22Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspenders']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_terminated']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendBlockers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_suspended']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_allSuspendAllowers']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
					_abstract := seqOfAbstractEntity[name = 'SuspendOnlyWhenNeeded_suspend']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM7::SystemFunction::NeverUnsuspend32NeverUnsuspend(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
		      let theSystem : SystemAnalysis = self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis) in
		      let allSynchCallSet : Collection(interaction::SequenceMessage) = theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
				->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
					and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
		 	.oclAsType(interaction::SequenceMessage) in
		      let allReplySet : Collection(interaction::SequenceMessage) = (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
					->select(eo|
					eo.oclIsTypeOf(interaction::SequenceMessage)
					and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
					and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
			).oclAsType(interaction::SequenceMessage) in
		      let otherTasks : Collection(SystemFunction) = theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self) in
		      let isAllocatedWithOthers : Integer = if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif in
				(
			allReplySet->size() = 0
			and
			isAllocatedWithOthers = 0
			and
			self.ownedFunctions->isEmpty()
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_NeverUnsuspend";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
					var theSystem : SystemAnalysis := self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis);
					allVarDefs->append("SystemFunction::theSystem"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allSynchCallSet : Collection(interaction::SequenceMessage) := theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
							->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::SYNCHRONOUS_CALL
								and eo.oclAsType(interaction::SequenceMessage).sendingFunction = self)
					 	.oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allSynchCallSet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var allReplySet : Collection(interaction::SequenceMessage) := (theSystem.containedCapabilityPkg.ownedCapabilities.oclAsType(Capability)->first().ownedScenarios.ownedMessages
								->select(eo|
								eo.oclIsTypeOf(interaction::SequenceMessage)
								and eo.oclAsType(interaction::SequenceMessage).kind = interaction::MessageKind::REPLY
								and eo.oclAsType(interaction::SequenceMessage).receivingFunction = self)
						).oclAsType(interaction::SequenceMessage);
					allVarDefs->append("SystemFunction::allReplySet"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var otherTasks : Collection(SystemFunction) := theSystem.ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->select(sf| sf <> self);
					allVarDefs->append("SystemFunction::otherTasks"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
					var isAllocatedWithOthers : Integer := if (  self.oclAsType(ecore::EObject)->closure(eo |if not eo.oclIsKindOf(SystemAnalysis) then eo.eContainer() else null endif)->select(s | s.oclIsKindOf(SystemAnalysis))->asSequence()->first().oclAsType(SystemAnalysis).ownedSystem.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->exists(sf| sf = self)) then 1 else 0 endif;
					allVarDefs->append("SystemFunction::isAllocatedWithOthers"); --to be exploited later. If you have an error close to here, please remove the explicit self when navigating to the def
			
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_unsuspend']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		





















mapping inMM1::Project::capellamodeller2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
		}; 
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map activated2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map started2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map terminated2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map suspended2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map unsuspend2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map isRunning2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemFunction.oclAsType(EClass)).oclAsType(SystemFunction)->map hasBeenElected2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map isWorking2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), System.oclAsType(EClass)).oclAsType(System)->map start2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), SystemAnalysis.oclAsType(EClass)).oclAsType(SystemAnalysis)->map ms2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ChangeEvent.oclAsType(EClass)).oclAsType(ChangeEvent)->map occurs2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map entering2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Mode.oclAsType(EClass)).oclAsType(Mode)->map leaving2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map start2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateMachine.oclAsType(EClass)).oclAsType(StateMachine)->map anyEventOrTime2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), StateTransition.oclAsType(EClass)).oclAsType(StateTransition)->map fire2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), AbstractEnd.oclAsType(EClass)).oclAsType(AbstractEnd)->map abstractEnd_occurs2MSE();
}		


	 	mapping inMM3::SystemFunction::activated2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_activated';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_activated')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::SystemFunction::started2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_started';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_started')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::SystemFunction::terminated2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_terminated';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "hasUnnamedLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_terminated')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::SystemFunction::suspended2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_suspended';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getFullLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_suspended')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::SystemFunction::unsuspend2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_unsuspend';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "destroy")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_unsuspend')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::SystemFunction::isRunning2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_isRunning';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_isRunning')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::SystemFunction::hasBeenElected2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctions->isEmpty()) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_hasBeenElected';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_hasBeenElected')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::System::isWorking2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.ownedFunctionalAllocation.function.oclAsType(SystemFunction)->size() > 0) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_isWorking';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_isWorking')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::System::start2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_start';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_start')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM3::SystemAnalysis::ms2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_ms';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_ms')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM4::ChangeEvent::occurs2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_occurs';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_occurs')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM4::Mode::entering2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_entering';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_entering')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM4::Mode::leaving2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_leaving';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_leaving')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM4::StateMachine::start2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_start';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_start')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM4::StateMachine::anyEventOrTime2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_anyEventOrTime';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_anyEventOrTime')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM4::StateTransition::fire2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().oclIsKindOf(StateMachine)) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_fire';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toString")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_fire')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::AbstractEnd::abstractEnd_occurs2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_abstractEnd_occurs';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "getLabel")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_abstractEnd_occurs')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
			
		






//priority stuff

mapping inMM1::Project::capellamodeller2Priority()  :Priority::PrioritySpecification  {
	thePrioritySpec := result;
	importedModel := object Priority::ImportStatement{
		importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
	}; 
}	




