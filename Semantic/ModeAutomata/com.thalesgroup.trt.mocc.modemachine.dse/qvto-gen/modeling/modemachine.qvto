import org.eclipse.gemoc.moccml_mapping.EclQVToHelper;
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
	modeltype inMM1 uses 'invalid';
	modeltype inMM2 uses 'invalid';
	modeltype inMM3 uses 'invalid';
	modeltype inMM4 uses 'invalid';
	modeltype inMM5 uses 'invalid';
	modeltype inMM6 uses 'invalid';

modeltype QVT 		uses 'http://www.eclipse.org/QVT/1.0.0/Operational';
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';
modeltype FeedBack 	uses 'http://timesquare.inria.fr/feedback';

transformation do_To_CCSL(in inM : inMM, out ccsl : TimeModel, out feedback : FeedBack);

property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};
property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;
property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;
property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};


query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoC.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoC.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoCC.moccml")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoCC.moccml")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM::Project]->asSequence()->first()-> map invalid2CCSL();
	inM.rootObjects()[inMM::Project]->asSequence()->first()-> map invalid2FeedBack();

	}

			
	mapping inMM::Project::invalid2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoC.ccslLib';
			alias := 'SMCubeMoC';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.gemoc.sample.smcube.moc.lib/ccsl/SMCubeMoCC.moccml';
			alias := 'SMCubeMoCC';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		////[ invalid ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2Clock();
		


		

		////[ invalid ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2Clock();
		////[ invalid ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2Clock();
		


		

		////[ invalid ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2Clock();
		


	}





//create the expressions...



	 	mapping inMM5::invalid::invalid2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_invalid';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(emde::ExtensibleElement).ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ClockRuntimeData))->first().oclAsType(ModeSimulation::ClockRuntimeData).oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(emde::ExtensibleElement).ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ClockRuntimeData))->first().oclAsType(ModeSimulation::ClockRuntimeData).oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "ticks")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM6::invalid::invalid2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_invalid';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onEnter")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM6::invalid::invalid2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_invalid';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onLeave")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM6::invalid::invalid2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_invalid';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::MachineRuntimeData))->first().oclAsType(ModeSimulation::MachineRuntimeData).oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		





















mapping inMM::Project::invalid2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
		}; 
		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), invalid.oclAsType(EClass)).oclAsType(invalid)->map invalid2MSE();






	}		


	 	mapping inMM5::invalid::invalid2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';

				caller := self.oclAsType(emde::ExtensibleElement).ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ClockRuntimeData))->first().oclAsType(ModeSimulation::ClockRuntimeData).oclAsType(EObject);
				action := self.oclAsType(emde::ExtensibleElement).ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ClockRuntimeData))->first().oclAsType(ModeSimulation::ClockRuntimeData).oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "ticks")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_invalid')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::invalid::invalid2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';

				caller := self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject);
				action := self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onEnter")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_invalid')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::invalid::invalid2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';

				caller := self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject);
				action := self.ownedExtensions->select(E | (E).oclIsTypeOf(ModeSimulation::ModeRuntimeData))->first().oclAsType(ModeSimulation::ModeRuntimeData).oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onLeave")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_invalid')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM6::invalid::invalid2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_invalid';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_invalid')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
			
		










